use serde::Serialize;

#[derive(Debug, Clone, Serialize)]
pub struct AlbLogEntry {
    /// The type of request or connection (e.g., "http", "https", "h2", "grpcs", "ws", "wss")
    pub r#type: String,

    /// The time when the load balancer generated a response to the client, in ISO 8601 format
    pub time: String,

    /// The resource ID of the load balancer
    pub elb: String,

    /// The IP address and port of the requesting client
    pub client: String,

    /// The IP address and port of the target that processed this request
    pub target: Option<String>,

    /// The total time elapsed from the time the load balancer received the request until it sent the request to a target
    pub request_processing_time: f64,

    /// The total time elapsed from the time the load balancer sent the request to a target until the target started to send the response headers
    pub target_processing_time: f64,

    /// The total time elapsed from the time the load balancer received the response header from the target until it started to send the response to the client
    pub response_processing_time: f64,

    /// The status code of the response generated by the load balancer
    pub elb_status_code: u16,

    /// The status code of the response from the target
    pub target_status_code: Option<u16>,

    /// The size of the request, in bytes, received from the client
    pub received_bytes: u64,

    /// The size of the response, in bytes, sent to the client
    pub sent_bytes: u64,

    /// The request line from the client (parsed)
    pub request: String,

    /// The request line from the client (parsed)
    pub request_method: String,
    pub request_url: String,
    pub request_http_version: String,

    /// A User-Agent string that identifies the client that originated the request
    pub user_agent: String,

    /// The SSL cipher (for HTTPS listeners)
    pub ssl_cipher: Option<String>,

    /// The SSL protocol (for HTTPS listeners)
    pub ssl_protocol: Option<String>,

    /// The Amazon Resource Name (ARN) of the target group
    pub target_group_arn: String,

    /// The contents of the X-Amzn-Trace-Id header
    pub trace_id: String,

    /// The SNI domain provided by the client during the TLS handshake (for HTTPS listeners)
    pub domain_name: Option<String>,

    /// The ARN of the certificate presented to the client (for HTTPS listeners)
    pub chosen_cert_arn: Option<String>,

    /// The priority value of the rule that matched the request
    pub matched_rule_priority: i32,

    /// The time when the load balancer received the request from the client, in ISO 8601 format
    pub request_creation_time: String,

    /// The actions taken when processing the request
    pub actions_executed: String,

    /// The URL of the redirect target for the location header of the HTTP response
    pub redirect_url: Option<String>,

    /// The error reason code
    pub error_reason: Option<String>,

    /// A list of IP addresses and ports for the targets that processed this request
    pub target_port_list: Vec<String>,

    /// A list of status codes from the responses of the targets
    pub target_status_code_list: Vec<u16>,

    /// The classification for desync mitigation
    pub classification: Option<String>,

    /// The classification reason code
    pub classification_reason: Option<String>,

    /// A unique opaque ID used to identify each connection
    pub conn_trace_id: Option<String>,
}

fn quoted_split(log_line: &str) -> Vec<String> {
    let mut parts = Vec::new();
    let mut current_part = String::new();
    let mut in_quotes = false;

    for c in log_line.chars() {
        match c {
            // TODO: escaping?
            '"' => {
                in_quotes = !in_quotes;
                current_part.push(c);
            }
            ' ' if !in_quotes => {
                if !current_part.is_empty() {
                    parts.push(current_part);
                    current_part = String::new();
                }
            }
            _ => current_part.push(c),
        }
    }

    if !current_part.is_empty() {
        parts.push(current_part);
    }
    parts
}

fn parse_option(opt: &str) -> Option<String> {
    if opt == "-" {
        None
    } else {
        Some(opt.to_string())
    }
}

impl AlbLogEntry {
    pub fn parse(log_line: &str) -> Result<Self, Box<dyn std::error::Error>> {
        let parts = quoted_split(log_line);

        if parts.len() < 29 {
            return Err("Invalid number of fields in log entry".into());
        }

        let request = parts[12]
            .trim_matches('"')
            .split_whitespace()
            .collect::<Vec<&str>>();

        Ok(AlbLogEntry {
            r#type: parts[0].to_string(),
            time: parts[1].to_string(),
            elb: parts[2].to_string(),
            client: parts[3].parse()?,
            target: parse_option(&parts[4]),
            request_processing_time: parts[5]
                .parse()
                .or(Err("Invalid request_processing_time"))?,
            target_processing_time: parts[6].parse().or(Err("Invalid target_processing_time"))?,
            response_processing_time: parts[7]
                .parse()
                .or(Err("Invalid response_processing_time"))?,
            elb_status_code: parts[8].parse().or(Err("Invalid elb_status_code"))?,
            target_status_code: parts[9].parse().ok(),
            received_bytes: parts[10].parse().or(Err("Invalid received_bytes"))?,
            sent_bytes: parts[11].parse().or(Err("Invalid sent_bytes"))?,
            request: parts[12].to_string(),
            #[allow(clippy::get_first)]
            request_method: request.get(0).unwrap_or(&"").to_lowercase().to_string(),
            request_url: request.get(1).unwrap_or(&"").to_string(),
            request_http_version: request.get(2).unwrap_or(&"").to_string(),
            user_agent: parts[13].trim_matches('"').to_string(),
            ssl_cipher: parse_option(&parts[14]),
            ssl_protocol: parse_option(&parts[15]),
            target_group_arn: parts[16].to_string(),
            trace_id: parts[17].trim_matches('"').to_string(),
            domain_name: parse_option(parts[18].trim_matches('"')),
            chosen_cert_arn: parse_option(parts[19].trim_matches('"')),
            matched_rule_priority: parse_option(&parts[20])
                .and_then(|s| s.parse().ok())
                .unwrap_or_default(),
            request_creation_time: parts[21].to_string(),
            actions_executed: parts[22]
                .trim_matches('"')
                .split(',')
                .map(String::from)
                .collect(),
            redirect_url: parse_option(parts[23].trim_matches('"')),
            error_reason: parse_option(parts[24].trim_matches('"')),
            target_port_list: parts[25]
                .trim_matches('"')
                .to_string()
                .split_whitespace()
                .map(String::from)
                .collect(),
            target_status_code_list: parse_option(parts[26].trim_matches('"'))
                .unwrap_or_default()
                .split_whitespace()
                .map(|s| s.parse().unwrap())
                .collect(),
            classification: parse_option(parts[27].trim_matches('"')),
            classification_reason: parse_option(parts[28].trim_matches('"')),
            conn_trace_id: parts.get(29).map(|s| s.to_string()),
        })
    }
}
